version "4.5"

class PsgHandler : EventHandler
{
	override void CheckReplacement(ReplaceEvent e)
	{
		if (!e.Replacement)
		{
			return;
		}

		switch (e.Replacement.GetClassName())
		{
			case 'BattleArmour':
				if (random[psgrand]() <= 48)
				{
					e.Replacement = 'PsgRandom';
				}
				break;
		}
	}

	override void WorldThingSpawned(WorldEvent e)
	{
		let bat = HDBattery(e.Thing);
		if (bat)
		{
			bat.ItemsThatUseThis.Push("HDPersonalShieldGenerator");
		}
	}
}

class HDPersonalShieldGenerator : HDWeapon
{
	enum PSlags
	{
		PSF_Elemental = 1,
		PSF_Medical = 2,
		PSF_Shocking = 4,
		PSF_Cloaking = 8 // [Ace] Why yes, I like my technology overpowered, how can you tell?
	}

	enum PSProperties
	{
		PSProp_Flags,
		PSProp_UseOffset,
		PSProp_Battery1,
		PSProp_Battery2,
		PSProp_Battery3,
		PSProp_ShieldRegenerated,
		PSProp_Degradation,
		PSProp_Mode,
		PSProp_UpgradePoints
	}

	action void A_AddOffset(int ofs)
	{
		invoker.WeaponStatus[PSProp_UseOffset] += ofs;
	}

	override bool AddSpareWeapon(actor newowner) { return AddSpareWeaponRegular(newowner); }
	override HDWeapon GetSpareWeapon(actor newowner , bool reverse, bool doselect) { return GetSpareWeaponRegular(newowner, reverse, doselect); }
	override string, double GetPickupSprite()
	{
		string main = "PSG"..min(Tiers, (WeaponStatus[PSProp_UpgradePoints] / PointsPerTier));
		return main..(GetBatteriesLoaded(1) > 0 && Enabled ? "B" : "A").."0", 0.2;
	}
	override string GetHelpText()
	{
		return WEPHELP_RELOAD.."  Reload battery\n"
		..WEPHELP_UNLOAD.."  Unload battery\n"
		..WEPHELP_FIRE.." or "..WEPHELP_ALTFIRE.."  Change slider position\n"
		..WEPHELP_ZOOM.."  Toggle on/off\n"
		..WEPHELP_FIREMODE.."+"..WEPHELP_USE.."  Strip picked up generator";
	}
	override double WeaponBulk()
	{
		return 20 + 10 * min(Tiers, (WeaponStatus[PSProp_UpgradePoints] / PointsPerTier)) + GetBatteriesLoaded() * ENC_BATTERY_LOADED;
	}
	override void LoadoutConfigure(string input)
	{
		InitializeWepStats(false);
		int points = GetLoadoutVar(input, "points", 1);
		if (points > 0)
		{
			WeaponStatus[PSProp_UpgradePoints] = points;
		}
		if (GetLoadoutVar(input, "elem", 1) > 0)
		{
			WeaponStatus[PSProp_Flags] |= PSF_Elemental;
		}
		if (GetLoadoutVar(input, "medical", 1) > 0)
		{
			WeaponStatus[PSProp_Flags] |= PSF_Medical;
		}
		if (GetLoadoutVar(input, "shock", 1) > 0)
		{
			WeaponStatus[PSProp_Flags] |= PSF_Shocking;
		}
		if (GetLoadoutVar(input, "cloak", 1) > 0)
		{
			WeaponStatus[PSProp_Flags] |= PSF_Cloaking;
		}
	}
	override void InitializeWepStats(bool idfa)
	{
		WeaponStatus[PSProp_Battery1] = 20;
		WeaponStatus[PSProp_Battery2] = 20;
		WeaponStatus[PSProp_Battery3] = 20;
	}

	override int GetSbarNum(int flags)
	{
		let HDHud = HDStatusBar(StatusBar);
		let shield = HDPersonalShield(FindInventory('HDPersonalShield'));
		if (shield)
		{
			HDHud.SavedColour = shield.Amount > 0 ? (Enabled ? Font.CR_GREEN : Font.CR_YELLOW) : Font.CR_RED;
			return max(0, shield.Amount);
		}
		return Super.GetSbarNum(flags);
	}

	clearscope int GetShieldColor()
	{
		switch (WeaponStatus[PSProp_UpgradePoints] / PointsPerTier)
		{
			default: return 0xFFFFFF;
			case 0: return 0xFF1111;
			case 1: return 0xFF8811;
			case 2: return 0xFFFF11;
			case 3: return 0x66FF11;
			case 4: return 0x11FFFF;
			case 5: return 0x1144FF;
			case 6: return 0x8811FF;
			case 7: return 0xFF11FF;
		}
	}

	override void AttachToOwner(Actor other)
	{
		let shield = HDPersonalShield(other.GiveInventoryType('HDPersonalShield'));
		if (shield)
		{
			shield.Amount = 0;
			shield.Depleted = true; // [Ace] Forced up effect to spawn.
		}
		Super.AttachToOwner(other);
	}

	override bool Use(bool pickup)
	{
		if (!pickup && owner && owner.player.cmd.buttons & BT_USE)
		{
			A_ToggleShield();
			return false;
		}
		return Super.Use(pickup);
	}

	private action void A_ToggleShield()
	{
		invoker.Enabled = !invoker.Enabled;
		invoker.owner.A_StartSound("PSG/Toggle", 9, pitch: invoker.Enabled ? 1.0 : 0.8);
	}

	override void DoEffect()
	{
		Super.DoEffect();

		Icon = TexMan.CheckForTexture(GetPickupSprite(), TexMan.Type_Any);

		// [Ace] Owner is an NPC, assume they're intelligent enough to know how to turn it on.
		if (!owner.player)
		{
			Enabled = true;
		}

		if (!Enabled)
		{
			return;
		}

		int base, extra;
		[base, extra] = GetEfficiency();
		int adj = GetAdjustedEfficiency(base + extra, WeaponStatus[PSProp_Degradation]);
		if (WeaponStatus[PSProp_ShieldRegenerated] >= adj)
		{
			WeaponStatus[PSProp_ShieldRegenerated] -= adj;
			if (adj > 0)
			{
				WeaponStatus[PSProp_Degradation]++;
			}
			for (int i = PSProp_Battery1; i <= PSProp_Battery3; ++i)
			{
				if (WeaponStatus[i] > 0)
				{
					WeaponStatus[i]--;
				}
			}
		}
		int batteries = GetBatteriesLoaded(1);
		if (batteries < 3)
		{
			Enabled = false;
		}
	}

	clearscope int GetBatteriesLoaded(int minCharge = 0)
	{
		int num = 0;
		for (int i = PSProp_Battery1; i <= PSProp_Battery3; ++i)
		{
			if (WeaponStatus[i] >= minCharge)
			{
				num++;
			}
		}
		return num;
	}

	int, int GetMaxShield() const
	{
		int base = WeaponStatus[PSProp_Mode] == 1 ? 1500 : 500;
		int extra = WeaponStatus[PSProp_Mode] == 1 ? 300 : 100;
		return base, extra * WeaponStatus[PSProp_UpgradePoints];
	}

	double GetThickness() const
	{
		return WeaponStatus[PSProp_Mode] == 1 ? 3.5 : 1.5;
	}

	private int, int GetEfficiency() const
	{
		return 600, 40 * WeaponStatus[PSProp_UpgradePoints];
	}

	private int GetAdjustedEfficiency(int base, int degradation) const
	{
		return max(0, base - 5 * degradation);
	}

	double, double GetRechargeRate() const
	{
		return WeaponStatus[PSProp_Mode] == 1 ? 1 : 3;
	}

	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl)
	{
		vector2 bob = hpl.hudbob * 0.3;
		int Offset = WeaponStatus[PSProp_UseOffset];
		bob.y += Offset;
		
		sb.DrawImage(GetPickupSprite(), (0, 25) + bob, sb.DI_SCREEN_CENTER | sb.DI_ITEM_CENTER_BOTTOM, box: (40, -1), scale:(2, 2));
		for (int i = 0; i < 3; ++i)
		{
			// The batmobile won't start.
			// Check the battery.
			// What's a tery?
			// *slap*
			int tery = hdw.WeaponStatus[PSProp_Battery1 + i];
			if (tery > -1)
			{
				string icon; int fontCol;
				[icon, fontCol] = AceCore.GetBatteryColor(tery);
				sb.DrawImage(icon, (-24, -11 + 15 * i) + bob, sb.DI_SCREEN_CENTER | sb.DI_ITEM_RIGHT | sb.DI_ITEM_VCENTER, box: (-1, 15));
				sb.DrawString(sb.mAmountFont, sb.FormatNumber(hdw.WeaponStatus[PSProp_Battery1 + i], 1, 2), (-22, -8 + 15 * i) + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_RIGHT, fontCol);
			}
		}

		int fontHeight = sb.pSmallFont.mFont.GetHeight() / 2;
		vector2 pos = (23, -18 - fontHeight);

		string hiLoStr = WeaponStatus[PSProp_Mode] == 1 ? "\c[Green]High\c-" : "\c[Red]Low\c-";

		// Mode.
		string str = String.Format("MOD "..Modes[WeaponStatus[PSProp_Mode]]);
		sb.DrawString(sb.pSmallFont, str, pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_GOLD);
		pos.y += 10;

		// Capacity.
		int base, extra;
		[base, extra] = GetMaxShield();
		str = String.Format("CAP: \c[Teal]%i \c[DarkGray](+%i)\c-", base + extra, extra);
		sb.DrawString(sb.pSmallFont, str, pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE);
		pos.y += 10;

		// Thickness.
		sb.DrawString(sb.pSmallFont, "THK: "..hiLoStr, pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE);
		pos.y += 10;

		// Efficiency.
		[base, extra] = GetEfficiency();
		int adj = GetAdjustedEfficiency(base + extra, WeaponStatus[PSProp_Degradation]);
		string efcol = "\c[Green]";
		if (adj < base * 0.20)
		{
			efcol = "\c[Black]";
		}
		else if (adj < base * 0.40)
		{
			efcol = "\c[Red]";
		}
		else if (adj < base * 0.60)
		{
			efcol = "\c[Orange]";
		}
		else if (adj < base * 0.80)
		{
			efcol = "\c[Yellow]";
		}

		int relative = adj - (base + extra);
		str = String.Format("EFF: \c[Teal]%i\c-/%s%i \c[DarkGray](%s%i)\c-", adj - WeaponStatus[PSProp_ShieldRegenerated], efcol, adj, (relative >= 0 ? "+" : ""), relative);
		sb.DrawString(sb.pSmallFont, str, pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE);
		pos.y += 10;

		// Recharge rate.
		sb.DrawString(sb.pSmallFont, "RCH: "..hiLoStr, pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE);
		pos.y += 10;

		if (WeaponStatus[PSProp_Flags] & PSF_Elemental)
		{
			sb.DrawString(sb.pSmallFont, "ENV: "..hiLoStr, pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE);
			pos.y += 10;
		}
		if (WeaponStatus[PSProp_Flags] & PSF_Medical)
		{
			sb.DrawString(sb.pSmallFont, "MED: "..hiLoStr, pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE);
			pos.y += 10;
		}
		if (WeaponStatus[PSProp_Flags] & PSF_Shocking)
		{
			sb.DrawString(sb.pSmallFont, "SHK: "..hiLoStr, pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE);
			pos.y += 10;
		}

		// Status.
		sb.DrawString(sb.pSmallFont, Enabled ? "\c[Green]Enabled\c-" : "\c[Red]Disabled\c-", pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT);
	}

	override void ActualPickup(Actor other, bool silent)
	{
		if (other.player && other.player.ReadyWeapon is 'HDPersonalShieldGenerator' && other.player.cmd.buttons & BT_FIREMODE)
		{
			if (WeaponStatus[PSProp_Degradation] > 120)
			{
				other.A_Log("Shield generator is too damaged to be used for parts.", true);
				return;	
			}
			let gen = HDPersonalShieldGenerator(other.FindInventory('HDPersonalShieldGenerator'));
			other.A_StartSound("PSG/Upgrade");
			other.A_Log("Shield generator was stripped for parts.", true);

			int pointsRemaining = WeaponStatus[PSProp_UpgradePoints] + 1;

			int toSpend = min(pointsRemaining, Tiers * PointsPerTier - gen.WeaponStatus[PSProp_UpgradePoints]);
			gen.WeaponStatus[PSProp_UpgradePoints] += toSpend;

			pointsRemaining -= toSpend;
			if (pointsRemaining > 0)
			{
				gen.WeaponStatus[PSProp_Degradation] = max(0, gen.WeaponStatus[PSProp_Degradation] - 10 * pointsRemaining);
			}

			gen.WeaponStatus[PSProp_Flags] |= WeaponStatus[PSProp_Flags];
			for (int i = PSProp_Battery1; i <= PSProp_Battery3; ++i)
			{
				if (WeaponStatus[i] >= 0)
				{
					HDMagAmmo.GiveMag(other, 'HDBattery', WeaponStatus[i]);
				}
			}
			Destroy();
			return;
		}
		Super.ActualPickup(other, silent);
	}

	override string PickupMessage()
	{
		string elemStr = WeaponStatus[PSProp_Flags] & PSF_Elemental ? "n elementally protective" : "";
		string regenStr = WeaponStatus[PSProp_Flags] & PSF_Medical ? "medical " : "";
		string shkStr = WeaponStatus[PSProp_Flags] & PSF_Shocking ? " with a shocking field" : "";
		return String.Format("You picked up a%s %spersonal shield generator%s.", elemStr, regenStr, shkStr);
	}

	const PointsPerTier = 5;
	const Tiers = 7; // [Ace] Actually Tiers + 1 because it's zero-based, so Tier 0 counts as Tier 1.
	static const string Modes[] = { "([]------):\c[Green] Standard\c-", "(------[]):\c[Red] Overcharged\c-" };
	bool Enabled;

	Default
	{
		+HDWEAPON.FITSINBACKPACK
		+INVENTORY.INVBAR
		+WEAPON.WIMPY_WEAPON
		-HDWEAPON.DROPTRANSLATION
		Inventory.Icon "PSG0A0";
		Inventory.PickupSound "weapons/pocket";
		Inventory.PickupMessage "You picked up a personal shield generator.";
		Tag "Personal Shield Generator";
		HDWeapon.RefId "psg";
		Scale 0.35;
	}

	States
	{
		RegisterSprites:
			PSG0 A 0; PSG1 A 0; PSG2 A 0; PSG3 A 0; PSG4 A 0; PSG5 A 0; PSG6 A 0; PSG7 A 0;

		Spawn:
			PSG0 A 1
			{
				if (!invoker.owner && invoker.Enabled)
				{
					invoker.Enabled = false;
				}

				string str = invoker.GetPickupSprite();
				sprite = GetSpriteIndex(str.Left(4));
				frame = int(invoker.GetBatteriesLoaded(1) > 0 && invoker.Enabled);
			}
			Loop;
		Select:
			TNT1 A 0 A_AddOffset(100);
			Goto Super::Select;
		Ready:
			TNT1 A 1
			{
				if (PressingUser3())
				{
					A_MagManager("HDBattery");
					return;
				}

				if (JustPressed(BT_ATTACK) && invoker.WeaponStatus[PSProp_Mode] > 0)
				{
					A_StartSound("PSG/Adjust", 10);
					invoker.WeaponStatus[PSProp_Mode]--;
				}
				else if (JustPressed(BT_ALTATTACK) && invoker.WeaponStatus[PSProp_Mode] < 1)
				{
					A_StartSound("PSG/Adjust", 10);
					invoker.WeaponStatus[PSProp_Mode]++;
				}

				int off = invoker.WeaponStatus[PSProp_UseOffset];
				if (off > 0)
				{
					invoker.WeaponStatus[PSProp_UseOffset] = off * 2 / 3;
				}

				A_WeaponReady((WRF_ALL | WRF_NOFIRE) & ~WRF_ALLOWUSER2);
			}
			Goto ReadyEnd;
		Unload:
			TNT1 A 20;
			TNT1 A 5
			{
				int count = invoker.GetBatteriesLoaded();
				if (count == 0)
				{
					return;
				}
				int last = invoker.WeaponStatus[PSProp_Battery1 + count - 1];
				if (PressingUnload() || PressingReload())
				{
					HDBattery.GiveMag(self, "HDBattery", last);
					A_StartSound("weapons/pocket", 9);
					A_SetTics(20);
				}
				else
				{
					HDBattery.SpawnMag(self, "HDBattery", last);
				}
				invoker.WeaponStatus[PSProp_Battery1 + count - 1] = -1;
			}
			Goto ReloadEnd;
		Reload:
			TNT1 A 14 A_StartSound("weapons/pocket", 9);
			TNT1 A 5
			{
				let bat = HDBattery(FindInventory('HDBattery'));
				int count = invoker.GetBatteriesLoaded();
				if (!bat || count == 3)
				{
					return;
				}
				invoker.WeaponStatus[PSProp_Battery1 + count] = bat.TakeMag(true);
				A_StartSound("weapons/vulcopen1", 8, CHANF_OVERLAP);
			}
			Goto ReloadEnd;
		Zoom:
			TNT1 A 15 A_ToggleShield();
			Goto Nope;
		ReloadEnd:
			TNT1 A 6;
			Goto Ready;
	}
}

class PsgRandom : IdleDummy
{
	States
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				let psg = HDPersonalShieldGenerator(Spawn("HDPersonalShieldGenerator", pos, ALLOW_REPLACE));
				if (!psg)
				{
					return;
				}

				for (int i = 0; i < psg.Tiers * psg.PointsPerTier; ++i)
				{
					if (random[psgrand](0, 1))
					{
						psg.WeaponStatus[psg.PSProp_UpgradePoints] = min(psg.Tiers * psg.PointsPerTier, psg.WeaponStatus[psg.PSProp_UpgradePoints] + randompick[psgrand](1, 1, 1, 1, 2));
					}
					else
					{
						break;
					}
				}

				HDF.TransferSpecials(self, psg);
				if (!random[psgrand](0, 5))
				{
					psg.WeaponStatus[psg.PSProp_Flags] |= (1 << random[psgrand](0, 2));
				}
				psg.InitializeWepStats(false);
			}
			Stop;
	}
}

class HDPersonalShield : HDMagicShield
{
	void ChangeMaxAmount(int newMax)
	{
		MaxAmount = newMax;
		if (Amount > newMax)
		{
			// [Ace] Where do you think that extra shield goes? Any trash mobs around you get vaporized if the value is high enough.
			int diff = Amount - newMax;
			double dist = HDCONST_ONEMETRE + HDCONST_ONEMETRE * (diff / 4000.0);
			HDActor.HDBlast(owner, dist, diff >> 4, dist * 0.5);
			
			// Console.Printf("rad: %.2f (%.2f), dam %i", dist / 37, dist / 37 * 0.5, diff >> 4);
			
			Deplete(diff, newMax);
		}
	}

	override void DoEffect()
	{
		if (owner.bCORPSE || owner.Health <= 0)
		{
			return;
		}

		if (SGen)
		{
			LastColor = SGen.GetShieldColor();
		}

		if (!SGen || !SGen.owner)
		{
			SGen = HDPersonalShieldGenerator(owner.FindInventory('HDPersonalShieldGenerator'));
			if (!SGen)
			{
				ChangeMaxAmount(0);
				UnCloak();
				Destroy();
				return;
			}
		}

		int base, extra;
		[base, extra] = SGen.GetMaxShield();
		ChangeMaxAmount(base + extra);

		if (!SGen.Enabled)
		{
			// [Ace] Passively deplete shields if generator is diabled. Increase rate the fewer charged batteries you have.
			int batteries = SGen.GetBatteriesLoaded(1);
			if (!Depleted && level.time % (2 << (batteries + 1)) == 0)
			{
				Deplete(1);
			}
			UnCloak();
			return;
		}

		let plr = HDPlayerPawn(owner);
		if (owner && Amount > 0)
		{
			if (!CoreHandler)
			{
				CoreHandler = AceCoreHandler(EventHandler.Find('AceCoreHandler'));
			}

			InterfaceRequest req = CoreHandler.GetRequest('DepletePsg', self);
			if (req)
			{
				Deplete(req.Arg.ToInt());
				req.Destroy();
				return;
			}

			bool overcharged = SGen.WeaponStatus[SGen.PSProp_Mode] == 1;
			if (SGen.WeaponStatus[SGen.PSProp_Flags] & SGen.PSF_Elemental)
			{
				owner.A_SetInventory('HDFireDouse', max(owner.CountInv('HDFireDouse'), overcharged ? 6 : 3));
			}
			if (SGen.WeaponStatus[SGen.PSProp_Flags] & SGen.PSF_Medical)
			{
				if (GetAge() % (overcharged ? 20 : 35) == 0)
				{
					if (plr && plr.woundcount > 0)
					{
						plr.woundcount--;
						plr.unstablewoundcount++;
						Amount -= 5;
					}
					if (owner.Health < (plr ? plr.MaxHealth() : owner.GetMaxHealth()))
					{
						if (HDMobBase(owner))
						{
							HDMobBase(owner).BodyDamage--;
						}
						owner.GiveBody(1);
						Amount -= 5;
					}
				}
				if (plr && GetAge() % (overcharged ? 210 : 350) == 0 && plr.burncount > 0)
				{
					plr.burncount--;
					Amount -= 20;
				}
			}
			if (SGen.WeaponStatus[SGen.PSProp_Flags] & SGen.PSF_Shocking && GetAge() % (overcharged ? 3 : 6) == 0)
			{
				BlockThingsIterator it = BlockThingsIterator.Create(owner, owner.radius * 2);
				while (it.Next())
				{
					if (it.thing is 'Babuin' && it.thing.Health > 0 && Babuin(it.thing).latchtarget == owner)
					{
						it.thing.DamageMobj(self, owner, random(1, 20), 'Electrical');
						Amount--;
					}
				}
			}
			if (SGen.WeaponStatus[SGen.PSProp_Flags] & SGen.PSF_Cloaking)
			{
				if (Amount >= MaxAmount * 0.75)
				{
					IsCloaked = true;
					owner.A_SetRenderStyle(0.2, STYLE_Translucent);
					owner.bShadow = true;
					owner.bCantSeek = true;
				}
				else
				{
					UnCloak();
				}
			}

			if (Amount < 0)
			{
				Amount = 0;
			}
		}
		
		if (ReactionTime > 0)
		{
			ReactionTime--;
		}
		else if (Amount >= 0 && Amount < MaxAmount)
		{
			double rate = SGen.GetRechargeRate();
			// https://www.desmos.com/calculator/bnngtfuad4

			double div = 2;
			if (SGen.WeaponStatus[SGen.PSProp_Mode] == 1)
			{
				div = 1.43;
			} 
			double fac = 1.0 - (sin(Amount / (MaxAmount / 2.0) * 90.0) / div);

			double adj = rate * fac;
			RechargeFrac++;
			while (RechargeFrac >= adj && Amount < MaxAmount)
			{
				RechargeFrac -= adj;
				Amount = min(Amount + 1, MaxAmount);
				SGen.WeaponStatus[SGen.PSProp_ShieldRegenerated] += SGen.WeaponStatus[SGen.PSProp_Mode] == 1 ? 2 : 1;
			}
		}

		if (Depleted && Amount > 0)
		{
			Depleted = false;
			owner.A_StartSound("PSG/ShieldUp", CHAN_BODY, CHANF_OVERLAP, 0.75);

			ShieldShieldlet sp = null;

			double startAlpha = 0;
			bool shift = false;
			for (double h = 0; h < owner.height / 1.5; h += HeightIncrease)
			{
				for (double a = 0; a < 360; a += AngleIncrease)
				{
					vector3 spawnPos = (owner.Vec2Angle(owner.radius * 1.5, a + (shift ? AngleIncrease / 2.0 : 0)), owner.pos.z + owner.height / 2);
					if (h == 0)
					{
						sp = ShieldShieldlet(SpawnSegment('ShieldShieldlet', spawnPos + (0, 0, h)));
						sp.bREFLECTIVE = true; sp.Alpha = startAlpha; sp.PeakAlpha = 1.0; sp.InSpeed = 0.20; sp.OutSpeed = frandom(0.10, 0.20);
					}
					else
					{
						sp = ShieldShieldlet(SpawnSegment('ShieldShieldlet', spawnPos + (0, 0, h)));
						sp.bREFLECTIVE = true; sp.Alpha = startAlpha; sp.PeakAlpha = 1.0; sp.InSpeed = 0.20; sp.OutSpeed = frandom(0.10, 0.20);
						sp = ShieldShieldlet(SpawnSegment('ShieldShieldlet', spawnPos - (0, 0, h)));
						sp.bREFLECTIVE = true; sp.Alpha = startAlpha; sp.PeakAlpha = 1.0; sp.InSpeed = 0.20; sp.OutSpeed = frandom(0.10, 0.20);
					}
				}
				startAlpha -= 0.1;
				shift = !shift;
			}
		}
	}

	override int, Name, int, int, int, int, int HandleDamage(int damage, Name mod, int flags, Actor inflictor, Actor source, int towound, int toburn, int tostun, int tobreak)
	{
		if (!owner || (flags & (DMG_NO_FACTOR | DMG_FORCED)) || Amount < 1 || !inflictor || inflictor == owner || inflictor is "HDBulletActor" || mod == 'bleedout' || mod == 'hot' || mod == 'cold' || mod == 'maxhpdrain' || mod == 'internal' || mod == 'holy' || mod == 'jointlock' || mod == 'staples')
		{
			return damage, mod, flags, towound, toburn, tostun, tobreak;
		}

		int blocked = min(Amount >> 1, damage, MaxAmount >> 1);
		damage -= blocked;

		bool supereffective = (mod == 'BFGBallAttack' || mod=='electrical' || mod=='balefire');

		Deplete(max(1, supereffective ? blocked << 2 : blocked));

		vector3 sparkpos = (0, 0, 0);
		if (inflictor && inflictor != source)
		{
			sparkpos = inflictor.pos;
		}
		else if (source)
		{
			sparkpos = (owner.pos.xy + owner.radius * (source.pos.xy - owner.pos.xy).unit(), owner.pos.z + min(owner.height, source.height * 0.6));
		}
		else
		{
			sparkpos = (owner.pos.xy, owner.pos.z + owner.height * 0.6);
		}

		SpawnImpactWeave(sparkPos);

		if(damage < 1)
		{
			if (!(flags & DMG_NO_PAIN) && blocked > (owner.SpawnHealth() >> 3) && random(0, 255) < owner.PainChance)
			{
				HDMobBase.ForcePain(owner);
			}
		}

		return damage,mod,flags,towound,toburn,tostun,tobreak;
	}

	override double, double OnBulletImpact(HDBulletActor bullet, double pen, double penshell, double hitangle, double deemedwidth, vector3 hitpos, vector3 vu, bool hitactoristall)
	{
		if (!owner || !bullet || Amount < 1)
		{
			return pen, penshell;
		}

		bullet.speed /= SGen.GetThickness();

		double bulletpower = pen * bullet.mass * 0.1;
		if (bulletpower < 1)
		{
			bulletpower = int(frandom(0, 1) < bulletpower);
		}

		int depleteAmt = int(min(bulletpower, Amount));
		if (depleteAmt <= 0)
		{
			if (bulletpower == 0)
			{
				return 0, penshell;
			}
			return pen, penshell;
		}

		Deplete(depleteAmt);

		SpawnImpactWeave(bullet.pos);

		owner.vel += (((owner.pos.xy, owner.pos.z + owner.height * 0.5) - bullet.pos).unit() * depleteAmt / owner.mass);
		owner.angle += DeltaAngle(owner.angle, owner.AngleTo(bullet)) * frandom(-0.005, 0.03);
		owner.pitch += frandom(-1.0, 1.0);

		double addpenshell = min(pen, Amount, MaxAmount >> 3);
		if (addpenshell > 0)
		{
			pen -= addpenshell;
			penshell += addpenshell;
		}
		return pen, penshell;
	}

	void Deplete(int amt, int maxAmt = 0)
	{
		Amount -= amt;
		if (Amount <= maxAmt)
		{
			if (maxAmt == 0)
			{
				Depleted = true;
				ReactionTime = 35 * 3;
				if (SGen)
				{
					// [Ace] For each upgrade, add 3 seconds reactivation delay.
					for (int i = 0; i < 3; ++i)
					{
						if (SGen.WeaponStatus[SGen.PSProp_Flags] & (1 << i))
						{
							ReactionTime += 35 * 3;
						}
					}
				}
			}
			Amount = maxAmt;
			owner.A_StartSound("PSG/ShieldBreak", CHAN_BODY, CHANF_OVERLAP, 0.75);

			ShieldShieldlet sp = null;

			bool shift = false;
			for (double h = 0; h < owner.height / 1.5; h += HeightIncrease)
			{
				for (double a = 0; a < 360; a += AngleIncrease)
				{
					if (random(0, 2))
					{
						continue;
					}
					vector3 spawnPos = (owner.Vec2Angle(owner.radius * 1.5, a + (shift ? AngleIncrease / 2.0 : 0)), owner.pos.z + owner.height / 2);

					double speedFac = amt / 4000.0;

					if (h == 0)
					{
						sp = ShieldShieldlet(SpawnSegment('ShieldShieldlet', spawnPos));
						sp.PeakAlpha = 1.0; sp.OutSpeed = frandom(0.03, 0.10); sp.bSTANDSTILL = true; sp.A_ChangeVelocity(min(0, frandom(-0.5, 1.0) - speedFac), 0, 0, CVF_RELATIVE);
					}
					else
					{
						sp = ShieldShieldlet(SpawnSegment('ShieldShieldlet', spawnPos + (0, 0, h)));
						sp.PeakAlpha = 1.0; sp.OutSpeed = frandom(0.03, 0.10); sp.bSTANDSTILL = true; sp.A_ChangeVelocity(min(0, frandom(-0.5, 1.0) - speedFac), 0, 0, CVF_RELATIVE);
						sp = ShieldShieldlet(SpawnSegment('ShieldShieldlet', spawnPos - (0, 0, h)));
						sp.PeakAlpha = 1.0; sp.OutSpeed = frandom(0.03, 0.10); sp.bSTANDSTILL = true; sp.A_ChangeVelocity(min(0, frandom(-0.5, 1.0) - speedFac), 0, 0, CVF_RELATIVE);
					}
				}
				shift = !shift;
			}
		}
	}

	private void SpawnImpactWeave(vector3 spawnPos)
	{
		vector3 diff = level.Vec3Diff(owner.pos, spawnPos);
		double centerAngle = VectorAngle(diff.x, diff.y);

		// [Ace] I tried to mathematically calculate how to do this, but after two hours I gave up. This isn't something that will change anytime soon, so it doesn't matter anyway.
		static const double spawnHeights[] =
		{
			HeightIncrease * 4,
			HeightIncrease * 3, HeightIncrease * 3,
			HeightIncrease * 2, HeightIncrease * 2, HeightIncrease * 2,
			HeightIncrease, HeightIncrease,
			0, 0, 0,
			-HeightIncrease, -HeightIncrease,
			-HeightIncrease * 2, -HeightIncrease * 2, -HeightIncrease * 2,
			-HeightIncrease * 3, -HeightIncrease * 3,
			-HeightIncrease * 4
		};

		static const double spawnAngles[] =
		{
			0,
			-AngleIncrease / 2, AngleIncrease / 2,
			-AngleIncrease, 0, AngleIncrease,
			-AngleIncrease / 2, AngleIncrease / 2,
			-AngleIncrease, 0, AngleIncrease,
			-AngleIncrease / 2, AngleIncrease / 2,
			-AngleIncrease, 0, AngleIncrease,
			-AngleIncrease / 2, AngleIncrease / 2,
			0
		};

		static const double spawnAlphas[] =
		{
			-1.0,
			-1.0, -1.0,
			-1.0, -0.5, -1.0,
			-0.5, -0.5,
			-1.0, 0, -1.0,
			-0.5, -0.5,
			-1.0, -0.5, -1.0,
			-1.0, -1.0,
			-1.0
		};

		vector2 randomShift = (frandom(5.0, 5.0), frandom(-4.0, 4.0));
		for (int i = 0; i < spawnHeights.Size(); ++i)
		{
			vector3 hexPos = (owner.Vec2Angle(owner.radius * 1.5, centerAngle + spawnAngles[i] + randomShift.x), spawnPos.z + spawnHeights[i] + randomShift.y);
			ShieldShieldlet sp = ShieldShieldlet(SpawnSegment('ShieldShieldlet', hexPos));
			sp.bREFLECTIVE = true; sp.Alpha = spawnAlphas[i]; sp.PeakAlpha = 0.75; sp.InSpeed = 0.5; sp.OutSpeed = 0.20;
		}
	}

	private ShieldShieldlet SpawnSegment(class<ShieldShieldlet> type, vector3 spawnPos)
	{
		ShieldShieldlet a = ShieldShieldlet(Spawn(type, spawnPos));
		a.angle = a.AngleTo(owner);
		//a.pitch = AceCore.PitchTo(a, owner);
		a.SetShade(LastColor);
		a.master = owner;
		return a;
	}

	private void UnCloak()
	{
		if (!owner || !IsCloaked)
		{
			return;
		}

		owner.bShadow = false;
		owner.bCantSeek = false;
		owner.A_SetRenderStyle(1, STYLE_Normal);

		for (Inventory next = owner.Inv; next != null; next = next.Inv)
		{
			if (next is 'PowerInvisibility')
			{
				next.DoEffect();
			}
		}

		IsCloaked = false;
	}

	override void DrawHUDStuff(HDStatusBar sb, HDPlayerPawn hpl, int hdflags, int gzflags)
	{
		if (hdflags & HDSB_AUTOMAP || !SGen || hpl.InvSel is 'HDPersonalShieldGenerator')
		{
			return;
		}
		
		sb.DrawImage(SGen.GetPickupSprite(), (100, -3), gzflags | sb.DI_ITEM_LEFT_BOTTOM, box: (20, -1));
		sb.DrawString(sb.pNewSmallFont, sb.FormatNumber(max(0, Amount), 1, 6), (120, -10), gzflags | sb.DI_TEXT_ALIGN_LEFT, Amount > 0 ? (SGen.Enabled ? Font.CR_GREEN : Font.CR_YELLOW) : Font.CR_RED, scale: (0.5, 0.5));
		for (int i = 0; i < 3; ++i)
		{
			int bat = SGen.WeaponStatus[SGen.PSProp_Battery1 + i];
			if (bat > -1)
			{
				sb.DrawImage(AceCore.GetBatteryColor(bat), (99, -23 + 8 * i), sb.DI_ITEM_RIGHT | sb.DI_ITEM_VCENTER | gzflags, box: (-1, 7));
			}
		}
	}

	// [Ace] These are calculated to work with the the current sprite scale, size, and distance. If any of these are incorrect, problems will happen.
	const HeightIncrease = 1.12;
	const AngleIncrease = 12.0;
	const RechargeTics = 5;
	bool Depleted;
	private bool IsCloaked;
	private int LastColor;
	private double RechargeFrac;
	private HDPersonalShieldGenerator SGen;
	private AceCoreHandler CoreHandler;

	Default
	{
		Inventory.MaxAmount 500;
		+INVENTORY.KEEPDEPLETED
		-INVENTORY.INVBAR
		HDDamageHandler.Priority 10002; // [Ace] Handle it before the shield from Arcanum.
	}
}

class ShieldShieldlet : Actor
{
	override void Tick()
	{
		// [Ace] I'm pulling a Matt and using unused flags instead of defining my own. Can it backfire? Maybe in a century. Can it backfire realistically? Probably not.
		if (master && !bSTANDSTILL)
		{
			vel = master.vel;
		}
		Super.Tick();
	}

	double InSpeed, OutSpeed, PeakAlpha;

	Default
	{
		+NOINTERACTION
		+NOBLOCKMAP
		Renderstyle "AddShaded";
		+WALLSPRITE
		Alpha 1.0;
		Scale 0.07;
	}

	States
	{
		Spawn:
			SLDS S 1 NoDelay
			{
				if (bREFLECTIVE)
				{
					alpha += InSpeed;
					if (alpha >= PeakAlpha)
					{
						bREFLECTIVE = false;
					}
				}
				else
				{
					A_FadeOut(OutSpeed);
				}
			}
			Loop;
	}
}