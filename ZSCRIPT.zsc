version "4.5"

class PsgHandler : EventHandler
{
	override void CheckReplacement(ReplaceEvent e)
	{
		if (!e.Replacement)
		{
			return;
		}

		switch (e.Replacement.GetClassName())
		{
			case 'BattleArmour':
				if (random[psgrand]() <= 48)
				{
					e.Replacement = 'PsgRandom';
				}
				break;
		}
	}

	override void WorldThingSpawned(WorldEvent e)
	{
		let bat = HDBattery(e.Thing);
		if (bat)
		{
			bat.ItemsThatUseThis.Push("HDPersonalShieldGenerator");
		}
	}
}

class HDPersonalShieldGenerator : HDWeapon
{
	enum PSlags
	{
		PSF_Elemental = 1,
		PSF_Regeneration = 2,
		PSF_Medical = 4,
	}

	enum PSProperties
	{
		PSProp_Flags,
		PSProp_UseOffset,
		PSProp_Battery1,
		PSProp_Battery2,
		PSProp_Battery3,
		PSProp_ShieldRegenerated,
		PSProp_Degradation,
		PSProp_Mode,
		PSProp_UpgradePoints
	}

	action void A_AddOffset(int ofs)
	{
		invoker.WeaponStatus[PSProp_UseOffset] += ofs;
	}

	override bool AddSpareWeapon(actor newowner) { return AddSpareWeaponRegular(newowner); }
	override HDWeapon GetSpareWeapon(actor newowner , bool reverse, bool doselect) { return GetSpareWeaponRegular(newowner, reverse, doselect); }
	override string, double GetPickupSprite()
	{
		string main = "PSG"..min(3, (WeaponStatus[PSProp_UpgradePoints] / 3));
		return main..(GetBatteriesLoaded(1) > 0 && Enabled ? "B" : "A").."0", 0.2;
	}
	override string GetHelpText()
	{
		string BaseString = WEPHELP_RELOAD.."  Reload battery\n"
		..WEPHELP_UNLOAD.."  Unload battery\n"
		..WEPHELP_FIRE.." or "..WEPHELP_ALTFIRE.."  Change slider position\n"
		..WEPHELP_ZOOM.."  Toggle on/off";
		return BaseString;
	}
	override double WeaponBulk()
	{
		return 20 * min(3, (WeaponStatus[PSProp_UpgradePoints] / 3)) + GetBatteriesLoaded() * ENC_BATTERY_LOADED;
	}
	override void LoadoutConfigure(string input)
	{
		InitializeWepStats(false);
		int points = GetLoadoutVar(input, "points", 1);
		if (points > 0)
		{
			WeaponStatus[PSProp_UpgradePoints] = points;
		}
		if (GetLoadoutVar(input, "elem", 1) > 0)
		{
			WeaponStatus[PSProp_Flags] |= PSF_Regeneration;
		}
		if (GetLoadoutVar(input, "regen", 1) > 0)
		{
			WeaponStatus[PSProp_Flags] |= PSF_Regeneration;
		}
		if (GetLoadoutVar(input, "medical", 1) > 0)
		{
			WeaponStatus[PSProp_Flags] |= PSF_Medical;
		}
	}
	override void InitializeWepStats(bool idfa)
	{
		WeaponStatus[PSProp_Battery1] = 20;
		WeaponStatus[PSProp_Battery2] = 20;
		WeaponStatus[PSProp_Battery3] = 20;
	}

	override int GetSbarNum(int flags)
	{
		let HDHud = HDStatusBar(StatusBar);
		let shield = HDPersonalShield(FindInventory('HDPersonalShield'));
		if (shield)
		{
			HDHud.SavedColour = shield.Amount > 0 ? (Enabled ? Font.CR_GREEN : Font.CR_YELLOW) : Font.CR_RED;
			return max(0, shield.Amount);
		}
		return Super.GetSbarNum(flags);
	}

	override void AttachToOwner(Actor other)
	{
		let shield = HDPersonalShield(other.GiveInventoryType('HDPersonalShield'));
		if (shield)
		{
			shield.Amount = 0;
			shield.Depleted = true;
		}
		Super.AttachToOwner(other);
	}

	override void DoEffect()
	{
		Super.DoEffect();

		int batteries = GetBatteriesLoaded(1);
		if (!Enabled)
		{
			return;
		}

		int base, extra;
		[base, extra] = GetEfficiency();
		int adj = GetAdjustedEfficiency(base + extra, WeaponStatus[PSProp_Degradation]);
		if (WeaponStatus[PSProp_ShieldRegenerated] >= adj)
		{
			WeaponStatus[PSProp_ShieldRegenerated] -= adj;
			if (adj > 0)
			{
				WeaponStatus[PSProp_Degradation] += WeaponStatus[PSProp_Mode] == 1 ? 2 : 1;
			}
			for (int i = PSProp_Battery1; i <= PSProp_Battery3; ++i)
			{
				if (WeaponStatus[i] > 0)
				{
					WeaponStatus[i]--;
				}
			}
		}
	}

	clearscope int GetBatteriesLoaded(int minCharge = 0)
	{
		int num = 0;
		for (int i = PSProp_Battery1; i <= PSProp_Battery3; ++i)
		{
			if (WeaponStatus[i] >= minCharge)
			{
				num++;
			}
		}
		return num;
	}

	int, int GetMaxShield() const
	{
		int base = WeaponStatus[PSProp_Mode] == 1 ? 3000 : 500;
		int extra = WeaponStatus[PSProp_Mode] == 1 ? 500 : 50;
		return base, extra * WeaponStatus[PSProp_UpgradePoints];
	}

	double GetThickness() const
	{
		return WeaponStatus[PSProp_Mode] == 1 ? 3.5 : 1.5;
	}

	private int, int GetEfficiency() const
	{
		return 800, 50 * WeaponStatus[PSProp_UpgradePoints];
	}

	private int GetAdjustedEfficiency(int base, int degradation) const
	{
		return max(0, base - 5 * degradation);
	}

	double, double GetRechargeRate() const
	{
		return WeaponStatus[PSProp_Mode] == 1 ? 1 : 3;
	}

	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl)
	{
		vector2 bob = hpl.hudbob * 0.3;
		int Offset = WeaponStatus[PSProp_UseOffset];
		bob.y += Offset;
		
		sb.DrawImage(GetPickupSprite(), (0, 25) + bob, sb.DI_SCREEN_CENTER | sb.DI_ITEM_CENTER_BOTTOM, box: (20, -1), scale:(2, 2));
		for (int i = 0; i < 3; ++i)
		{
			// The batmobile won't start.
			// Check the battery.
			// What's a tery?
			// *slap*
			int tery = hdw.WeaponStatus[PSProp_Battery1 + i];
			if (tery > -1)
			{
				string icon; int fontCol;
				[icon, fontCol] = AceCore.GetBatteryColor(tery);
				sb.DrawImage(icon, (-14, -11 + 15 * i) + bob, sb.DI_SCREEN_CENTER | sb.DI_ITEM_RIGHT | sb.DI_ITEM_VCENTER, box: (-1, 15));
				sb.DrawString(sb.mAmountFont, sb.FormatNumber(hdw.WeaponStatus[PSProp_Battery1 + i], 1, 2), (-12, -8 + 15 * i) + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_RIGHT, fontCol);
			}
		}

		int batteries = GetBatteriesLoaded(1);

		int fontHeight = sb.pSmallFont.mFont.GetHeight() / 2;
		vector2 pos = (13, -18 - fontHeight);

		string hiLoStr = WeaponStatus[PSProp_Mode] == 1 ? "\c[Green]High\c-" : "\c[Red]Low\c-";

		// Mode.
		string str = String.Format("MOD "..Modes[WeaponStatus[PSProp_Mode]]);
		sb.DrawString(sb.pSmallFont, str, pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_GOLD);
		pos.y += 10;

		// Capacity.
		int base, extra;
		[base, extra] = GetMaxShield();
		str = String.Format("CAP: \c[Teal]%i \c[DarkGray](+%i)\c-", base + extra, extra);
		sb.DrawString(sb.pSmallFont, str, pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE);
		pos.y += 10;

		// Thickness.
		sb.DrawString(sb.pSmallFont, "THK: "..hiLoStr, pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE);
		pos.y += 10;

		// Efficiency.
		[base, extra] = GetEfficiency();
		int adj = GetAdjustedEfficiency(base + extra, WeaponStatus[PSProp_Degradation]);
		string efcol = "\c[Green]";
		if (adj < base * 0.20)
		{
			efcol = "\c[Black]";
		}
		else if (adj < base * 0.40)
		{
			efcol = "\c[Red]";
		}
		else if (adj < base * 0.60)
		{
			efcol = "\c[Orange]";
		}
		else if (adj < base * 0.80)
		{
			efcol = "\c[Yellow]";
		}

		int relative = adj - (base + extra);
		str = String.Format("EFF: \c[Teal]%i\c-/%s%i \c[DarkGray](%s%i)\c-", adj - WeaponStatus[PSProp_ShieldRegenerated], efcol, adj, (relative >= 0 ? "+" : ""), relative);
		sb.DrawString(sb.pSmallFont, str, pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE);
		pos.y += 10;

		// Recharge rate.
		sb.DrawString(sb.pSmallFont, "RCH: "..hiLoStr, pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE);
		pos.y += 10;

		if (WeaponStatus[PSProp_Flags] & PSF_Elemental)
		{
			sb.DrawString(sb.pSmallFont, "ENV: "..hiLoStr, pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE);
			pos.y += 10;
		}
		if (WeaponStatus[PSProp_Flags] & PSF_Regeneration)
		{
			sb.DrawString(sb.pSmallFont, "REG: "..hiLoStr, pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE);
			pos.y += 10;
		}
		if (WeaponStatus[PSProp_Flags] & PSF_Medical)
		{
			sb.DrawString(sb.pSmallFont, "MED: "..hiLoStr, pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE);
			pos.y += 10;
		}

		// Status.
		sb.DrawString(sb.pSmallFont, Enabled ? "\c[Green]Enabled\c-" : "\c[Red]Disabled\c-", pos + bob, sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT);
	}

	override void ActualPickup(Actor other, bool silent)
	{
		if (other.player && other.player.ReadyWeapon is 'HDPersonalShieldGenerator' && other.player.cmd.buttons & BT_FIREMODE)
		{
			if (WeaponStatus[PSProp_Degradation] > 120)
			{
				other.A_Log("Shield generator is too damaged to be used for parts.", true);
				return;	
			}
			let gen = HDPersonalShieldGenerator(other.FindInventory('HDPersonalShieldGenerator'));
			other.A_StartSound("PSG/Upgrade");
			other.A_Log("Shield generator was stripped for parts.", true);
			gen.WeaponStatus[PSProp_UpgradePoints] += WeaponStatus[PSProp_UpgradePoints] + 1;
			Destroy();
			return;
		}
		Super.ActualPickup(other, silent);
	}

	override string PickupMessage()
	{
		string elemStr = WeaponStatus[PSProp_Flags] & PSF_Elemental ? "protective " : "";
		string regenStr = WeaponStatus[PSProp_Flags] & PSF_Regeneration ? "regenerative " : "";
		string medStr = WeaponStatus[PSProp_Flags] & PSF_Medical ? " with a medical field" : "";
		return String.Format("You picked up a %s%s personal shield generator%s.", elemStr, regenStr, medStr);
	}

	static const string Modes[] = { "([]------):\c[Green] Standard\c-", "(------[]):\c[Red] Overcharged\c-" };
	bool Enabled;

	Default
	{
		+HDWEAPON.FITSINBACKPACK
		+INVENTORY.INVBAR
		+WEAPON.WIMPY_WEAPON
		-HDWEAPON.DROPTRANSLATION
		Inventory.Icon "PSG0A0";
		Inventory.PickupSound "weapons/pocket";
		Inventory.PickupMessage "You picked up a personal shield generator.";
		Tag "Personal Shield Generator";
		HDWeapon.RefId "psg";
		Scale 0.35;
	}

	States
	{
		RegisterSprites:
			PSG0 A 0; PSG1 A 0; PSG2 A 0; PSG3 A 0;

		Spawn:
			PSG0 A 1
			{
				string str = invoker.GetPickupSprite();
				sprite = GetSpriteIndex(str.Left(4));
				frame = int(invoker.GetBatteriesLoaded(1) > 0);
			}
			Loop;
		Select:
			TNT1 A 0 A_AddOffset(100);
			Goto Super::Select;
		Ready:
			TNT1 A 1
			{
				if (PressingUser3())
				{
					A_MagManager("HDBattery");
					return;
				}

				if (JustPressed(BT_ATTACK) && invoker.WeaponStatus[PSProp_Mode] > 0)
				{
					A_StartSound("PSG/Adjust", 10);
					invoker.WeaponStatus[PSProp_Mode]--;
				}
				else if (JustPressed(BT_ALTATTACK) && invoker.WeaponStatus[PSProp_Mode] < 1)
				{
					A_StartSound("PSG/Adjust", 10);
					invoker.WeaponStatus[PSProp_Mode]++;
				}

				int off = invoker.WeaponStatus[PSProp_UseOffset];
				if (off > 0)
				{
					invoker.WeaponStatus[PSProp_UseOffset] = off * 2 / 3;
				}

				A_WeaponReady((WRF_ALL | WRF_NOFIRE) & ~WRF_ALLOWUSER2);
			}
			Goto ReadyEnd;
		Unload:
			TNT1 A 20;
			TNT1 A 5
			{
				int count = invoker.GetBatteriesLoaded();
				if (count == 0)
				{
					return;
				}
				int last = invoker.WeaponStatus[PSProp_Battery1 + count - 1];
				if (PressingUnload() || PressingReload())
				{
					HDBattery.GiveMag(self, "HDBattery", last);
					A_StartSound("weapons/pocket", 9);
					A_SetTics(20);
				}
				else
				{
					HDBattery.SpawnMag(self, "HDBattery", last);
				}
				invoker.WeaponStatus[PSProp_Battery1 + count - 1] = -1;
				invoker.Icon = TexMan.CheckForTexture(invoker.GetPickupSprite(), TexMan.Type_Any);
			}
			Goto ReloadEnd;
		Reload:
			TNT1 A 14 A_StartSound("weapons/pocket", 9);
			TNT1 A 5
			{
				let bat = HDBattery(FindInventory('HDBattery'));
				int count = invoker.GetBatteriesLoaded();
				if (!bat || count == 3)
				{
					return;
				}
				invoker.WeaponStatus[PSProp_Battery1 + count] = bat.TakeMag(true);
				A_StartSound("weapons/vulcopen1", 8, CHANF_OVERLAP);
				invoker.Icon = TexMan.CheckForTexture(invoker.GetPickupSprite(), TexMan.Type_Any);
			}
			Goto ReloadEnd;
		Zoom:
			TNT1 A 15
			{
				invoker.Enabled = !invoker.Enabled;
				A_StartSound("PSG/Toggle", 9, pitch: invoker.Enabled ? 1.0 : 0.8);
				invoker.Icon = TexMan.CheckForTexture(invoker.GetPickupSprite(), TexMan.Type_Any);
			}
			Goto Nope;
		ReloadEnd:
			TNT1 A 6;
			Goto Ready;
	}
}

class PsgRandom : IdleDummy
{
	States
	{
		Spawn:
			TNT1 A 0 nodelay
			{
				let psg = HDPersonalShieldGenerator(Spawn("HDPersonalShieldGenerator", pos, ALLOW_REPLACE));
				if (!psg)
				{
					return;
				}

				HDF.TransferSpecials(self, psg);
				for (int i = 0; i < 3; ++i)
				{
					if (!random[psgrand](0, 3))
					{
						psg.WeaponStatus[psg.PSProp_Flags] |= (1 << i);
					}
				}
				psg.InitializeWepStats(false);
			}
			Stop;
	}
}

class HDPersonalShield : HDMagicShield
{
	void ChangeMaxAmount(int newMax)
	{
		MaxAmount = newMax;
		if (Amount > newMax)
		{
			// [Ace] Where do you think that extra shield goes?
			owner.DamageMobj(self, self, (Amount - newMax) >> 5, 'Bashing', DMG_NO_ARMOR | DMG_FORCED);
			Amount = MaxAmount;

			owner.A_StartSound("misc/mobshieldx", CHAN_BODY, CHANF_OVERLAP, 0.75);
			for (int i = 0; i < 10; ++i)
			{
				vector3 rpos = owner.pos + (frandom(-owner.radius, owner.radius), frandom(-owner.radius, owner.radius), frandom(0, owner.height));
				Actor spk = Spawn("ShieldSpark", rpos, ALLOW_REPLACE);
				spk.vel = (frandom(-2, 2), frandom(-2, 2), frandom(-2, 2)) + owner.vel;
			}
		}
	}

	override void DoEffect()
	{
		if (owner.bCORPSE || owner.Health <= 0)
		{
			return;
		}

		if (!SGen || !SGen.owner)
		{
			SGen = HDPersonalShieldGenerator(owner.FindInventory('HDPersonalShieldGenerator'));
			if (!SGen)
			{
				ChangeMaxAmount(0);
				Destroy();
				return;
			}
		}

		int batteries = SGen.GetBatteriesLoaded(1);
		if (batteries < 3)
		{
			SGen.Enabled = false;
		}
		else
		{
			int base, extra;
			[base, extra] = SGen.GetMaxShield();
			int newMax = base + extra;
			ChangeMaxAmount(newMax);
		}

		if (!SGen.Enabled)
		{
			return;
		}

		let plr = HDPlayerPawn(owner);
		if (plr && Amount > 0)
		{
			bool overcharged = SGen.WeaponStatus[SGen.PSProp_Mode] == 1;
			if (SGen.WeaponStatus[SGen.PSProp_Flags] & SGen.PSF_Elemental)
			{
				plr.A_GiveInventory('HDFireDouse', overcharged ? 2 : 1);
			}
			if (SGen.WeaponStatus[SGen.PSProp_Flags] & SGen.PSF_Regeneration && GetAge() % (overcharged ? 20 : 35) == 0 && plr.Health < plr.MaxHealth())
			{
				plr.GiveBody(1);
			}
			if (SGen.WeaponStatus[SGen.PSProp_Flags] & SGen.PSF_Regeneration && GetAge() % (overcharged ? 20 : 35) == 0 && plr.woundcount > 0)
			{
				plr.woundcount--;
				plr.unstablewoundcount++;
			}
		}
		
		if (UnDepleteTimer > 0)
		{
			UnDepleteTimer--;
		}
		else if (Amount >= 0 && Amount < MaxAmount)
		{
			double rate = SGen.GetRechargeRate();
			// https://www.desmos.com/calculator/bnngtfuad4

			double div = 2;
			if (SGen.WeaponStatus[SGen.PSProp_Mode] == 1)
			{
				div = 1.43;
			} 
			double fac = 1.0 - (sin(Amount / (MaxAmount / 2.0) * 90.0) / div);

			double adj = rate * fac;
			RechargeFrac++;
			while (RechargeFrac >= adj && Amount < MaxAmount)
			{
				RechargeFrac -= adj;
				Amount = min(Amount + 1, MaxAmount);
				SGen.WeaponStatus[SGen.PSProp_ShieldRegenerated]++;
			}
		}
		else if (Amount < 0)
		{
			UnDepleteTimer = 35 * 3;

			// [Ace] For each upgrade, add 3 seconds reactivation delay.
			for (int i = 0; i < 3; ++i)
			{
				if (SGen.WeaponStatus[SGen.PSProp_Flags] & (1 << i))
				{
					UnDepleteTimer += 35 * 3;
				}
			}
			Depleted = true;
			Amount = 0;
		}

		if (Depleted && Amount > 0)
		{
			Depleted = false;
			if (hd_debug)
			{
				Console.Printf(owner.GetClassName().." shield restored!");
			}
			owner.A_StartSound("misc/mobshieldf", CHAN_BODY, CHANF_OVERLAP, 0.75);
			for (int i = 0; i < 10; ++i)
			{
				vector3 rpos = owner.pos + (frandom(-owner.radius, owner.radius), frandom(-owner.radius, owner.radius), frandom(0, owner.height));
				actor spk = actor.Spawn("ShieldSpark", rpos, ALLOW_REPLACE);
				vector3 sv = spk.Vec3To(owner);
				sv.z += height / 2;
				spk.vel = sv * 0.02;
			}
		}
	}

	override double, double OnBulletImpact(HDBulletActor bullet, double pen, double penshell, double hitangle, double deemedwidth, vector3 hitpos, vector3 vu, bool hitactoristall)
	{
		bullet.speed /= SGen.GetThickness();
		return Super.OnBulletImpact(bullet, pen, penshell, hitangle, deemedwidth, hitpos, vu, hitactoristall);
	}

	override void DrawHUDStuff(HDStatusBar sb, HDPlayerPawn hpl, int hdflags, int gzflags)
	{
		if (hdflags & HDSB_AUTOMAP || !SGen || hpl.InvSel is 'HDPersonalShieldGenerator')
		{
			return;
		}
		
		sb.DrawImage(SGen.GetPickupSprite(), (100, -3), gzflags | sb.DI_ITEM_LEFT_BOTTOM, box: (10, -1));
		sb.DrawString(sb.pNewSmallFont, sb.FormatNumber(max(0, Amount), 1, 6), (110, -10), gzflags | sb.DI_TEXT_ALIGN_LEFT, Amount > 0 ? (SGen.Enabled ? Font.CR_GREEN : Font.CR_YELLOW) : Font.CR_RED, scale: (0.5, 0.5));
		for (int i = 0; i < 3; ++i)
		{
			int bat = SGen.WeaponStatus[SGen.PSProp_Battery1 + i];
			if (bat > -1)
			{
				sb.DrawImage(AceCore.GetBatteryColor(bat), (99, -23 + 8 * i), sb.DI_ITEM_RIGHT | sb.DI_ITEM_VCENTER | gzflags, box: (-1, 7));
			}
		}
	}

	const RechargeTics = 5;
	bool Depleted;
	private int UnDepleteTimer;
	private double RechargeFrac;
	private HDPersonalShieldGenerator SGen;

	Default
	{
		Inventory.MaxAmount 500;
		+INVENTORY.KEEPDEPLETED
		-INVENTORY.INVBAR
		HDDamageHandler.Priority 10002; // [Ace] Handle it before the shield from Arcanum.
	}
}